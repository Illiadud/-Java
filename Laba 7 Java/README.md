### 1. Для чого призначений Collections Framework?
**Collections Framework** у Java — це набір класів та інтерфейсів, що забезпечує структури даних і алгоритми для роботи з колекціями (списками, множинами, чергами, мапами тощо). Він надає гнучкі та стандартизовані інструменти для маніпуляцій з даними, таких як сортування, пошук, видалення, об'єднання та ін.

### 2. В чому полягає різниця між масивами та колекціями?
- **Розмір**: Масиви мають фіксований розмір, тоді як колекції можуть динамічно змінювати свій розмір.
- **Функціональність**: Колекції надають широкий набір методів для роботи з даними (наприклад, додавання, видалення, пошук), а масиви цього не мають.
- **Типізація**: Масиви строго типізовані, тоді як колекції можуть бути типізованими (через дженерики) або нетипізованими.

### 3. Які особливі властивості є у списків порівняно з іншими типами колекцій?
- **Порядок елементів**: Списки зберігають порядок додавання елементів.
- **Доступ за індексом**: Списки дозволяють звертатися до елементів за індексом.
- **Дублікати**: Списки допускають наявність дублікатів, на відміну від деяких інших колекцій, таких як множини (`Set`).

### 4. Чим списки відрізняються від масивів?
- **Розмір**: Списки динамічно змінюють свій розмір, масиви мають фіксований розмір.
- **Методи**: Списки підтримують методи додавання, видалення, пошуку та сортування елементів, масиви таких методів не мають.
- **Типи даних**: Масиви строго типізовані, а списки можна використовувати з дженериками для забезпечення типобезпеки.

### 5. Чим ArrayList відрізняється від LinkedList? Який з них у яких випадках краще використовувати?
- **ArrayList**:
  - Реалізований на основі масиву.
  - Підходить для операцій швидкого доступу за індексом (`O(1)`).
  - Повільний для операцій вставки та видалення елементів у середині списку, оскільки вимагає зсуву елементів.
  - Краще використовувати, коли необхідний швидкий доступ за індексом.

- **LinkedList**:
  - Реалізований на основі двобічного зв'язного списку.
  - Швидкий для вставки та видалення елементів у середині або на початку списку (`O(1)` для вставки).
  - Повільний для доступу за індексом, оскільки потребує обходу списку (`O(n)`).
  - Краще використовувати, коли важливі часті вставки або видалення елементів.

### 6. Що таке Iterator? В чому полягають переваги використання ітератора у порівнянні з класичним циклом?
**Iterator** — це інтерфейс, який надає механізм для послідовного доступу до елементів колекції без знання її внутрішньої реалізації. 

**Переваги**:
- **Абстракція**: Ітератор дозволяє працювати з будь-яким типом колекцій однаково, незалежно від їх реалізації.
- **Безпечне видалення**: Ітератор дозволяє видаляти елементи під час обходу, чого не можна зробити у класичному циклі без ризику помилок.
- **Гнучкість**: Ітератор надає методи, які спрощують роботу з даними, наприклад `hasNext()` і `next()`.

### 7. Що таке типізовані та нетипізовані колекції?
- **Типізовані колекції**: Колекції, які використовують дженерики для визначення типу елементів, наприклад `ArrayList<String>`. Забезпечують типобезпеку і запобігають помилкам типізації під час компіляції.
- **Нетипізовані колекції**: Колекції без визначеного типу, наприклад `ArrayList`, що можуть містити елементи різних типів, але не захищені від помилок типізації.

### 8. Для чого потрібен інтерфейс RandomAccess?
**RandomAccess** — це маркерний інтерфейс, який вказує, що реалізація списку забезпечує швидкий доступ до елементів за індексом (наприклад, `ArrayList`). Його наявність дозволяє алгоритмам оптимізувати обробку, якщо список підтримує доступ за індексом із постійною складністю `O(1)`.

### 9. Чим Collection відрізняється від Collections?
- **Collection**: Інтерфейс, який є базовим для всіх колекцій у Java (наприклад, `List`, `Set`, `Queue`).
- **Collections**: Утилітний клас, що містить статичні методи для роботи з колекціями, такі як сортування, пошук, синхронізація та створення незмінних колекцій.
