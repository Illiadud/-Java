### 1. Чим змінна відрізняється від масиву?

- **Змінна**: це одинична комірка пам'яті для збереження одного значення.
- **Масив**: це структура даних, яка дозволяє зберігати множину значень одного типу, доступних через індекси.

---

### 2. Що таке стек? Що таке купа? Яка між ними різниця?

- **Стек**: це область пам'яті для зберігання локальних змінних і викликів методів. Пам'ять виділяється та звільняється за принципом LIFO (останнім зайшло — першим вийшло).
- **Купа**: це область пам'яті для динамічного виділення об'єктів і масивів. Пам'ять контролюється збирачем сміття (Garbage Collector).

**Різниця**:
- Стек швидший, але обмежений розміром.
- Купа більша, але доступ до неї повільніший.

---

### 3. Чи можуть змінні та масиви розташовуватися у стеку чи купі?

- **Змінна**:  
  - Локальні змінні розташовуються у стеку.  
  - Змінні, що є полями об’єктів, зберігаються у купі разом із об'єктом.  

- **Масив**:  
  - Масиви завжди розташовані у купі.  
  - Посилання на масив може бути у стеку (як локальна змінна) або у купі (як поле об’єкта).

---

### 4. Чим посилання на масив відрізняється від самого масиву?

- **Посилання на масив**: це змінна, яка зберігає адресу масиву в пам'яті.  
- **Масив**: це фактична структура даних, що займає місце в пам'яті.

**Розташування посилання**:
- У стеку (як локальна змінна).
- У купі (як поле об’єкта).

---

### 5. Якщо масив складається з 10 комірок, які індекси мають перша та остання комірки?

- Перша комірка має індекс **0**.  
- Остання комірка має індекс **9**.

---

### 6. Що буде, якщо звернутися до неіснуючої комірки у масиві?

**Результат**: буде викинуто виключення `ArrayIndexOutOfBoundsException`.

---

### 7. Ініціалізація нового масиву без явного задання значень:

- **Проініціалізовані значення за замовчуванням**:  
  - Для чисел — `0`.  
  - Для `boolean` — `false`.  
  - Для об'єктів — `null`.

- **Довільні значення з пам'яті** не використовуються, оскільки Java автоматично очищує пам'ять.

---

### 8. Як дізнатися номер першої та останньої комірки масиву, якщо відомо лише посилання?

- **Перша комірка**: завжди має індекс `0`.  
- **Остання комірка**: індекс дорівнює `array.length - 1`.

---

### 9. Як змінити розмір масиву?

Розмір масиву в Java не можна змінити після створення. Можна створити новий масив і скопіювати в нього дані зі старого:  
```java
int[] oldArray = {1, 2, 3};
int[] newArray = new int[5];
System.arraycopy(oldArray, 0, newArray, 0, oldArray.length);
```

---

### 10. Що відбувається з масивом при копіюванні посилання на нього?

Копіюється тільки посилання, а не сам масив. Зміни через одне посилання будуть видимі через інше.

---

### 11. Що відбувається з масивом при втраті посилання на нього?

Якщо посилання втрачене, об'єкт масиву стає недоступним і може бути видалений збирачем сміття.

---

### 12. Чим відрізняються `for` та `for-each` при роботі з масивами?

- **`for`**: дозволяє працювати з індексами, змінювати значення елементів.  
  _Недолік_: більше коду.

- **`for-each`**: працює безпосередньо з елементами масиву.  
  _Недолік_: не можна змінювати елементи або отримувати їх індекси.

_Приклад_:
```java
int[] array = {1, 2, 3};
// for
for (int i = 0; i < array.length; i++) {
    System.out.println(array[i]);
}
// for-each
for (int element : array) {
    System.out.println(element);
}
```

---

### 13. Чи можна записати `int` у `double[]` та навпаки?

- **`int` у `double[]`**: так, через автоматичне приведення типів.  
  _Приклад_:  
  ```java
  double[] array = {1, 2.5, 3};
  ```

- **`double` у `int[]`**: ні, буде помилка компіляції через втрату точності.
